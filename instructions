Plan: add “MAC Address” feature (API + logic) — simple, step-by-step

Nice — we’ll build a small, well-structured Express API that accepts a MAC address payload from your frontend, validates it, and forwards it to the Cisco ISE ERS POST endpoint you gave:

POST https://10.92.148.149:443/ers/config/endpoint

We’ll keep DB work out for now (you said you’ll add it later) but structure the code so persisting later is trivial.

I’ll show:
	1.	environment variables you need
	2.	route → controller → service layout
	3.	input validation (basic, prevents garbage)
	4.	axios call to ERS with proper headers/auth and TLS notes
	5.	error handling and example responses
	6.	curl example + how frontend should call /api/mac
	7.	where to plug DB later

⸻

1) Environment variables (add to .env / .env.uat)

PORT=3000

# Cisco ISE ERS (target)
ERS_BASE_URL=https://10.92.148.149:443
ERS_USER=ersUsername
ERS_PASS=ersPassword

# Optional: set to "false" in production if you have proper CA
ERS_REJECT_UNAUTHORIZED=false
ERS_TIMEOUT_MS=10000

Security note: Never commit .env to git. Use deploy secret mechanism for production.

⸻

2) Folder / files (small, easy structure)

backend/
  controllers/
    macController.js
  routes/
    macRoutes.js
  services/
    ersService.js
  validators/
    macValidator.js
server.js

You likely already have server.js and backend/routes — just add these.

⸻

3) Route (HTTP surface) — backend/routes/macRoutes.js

const express = require('express');
const router = express.Router();
const macController = require('../controllers/macController');
const { validateMac } = require('../validators/macValidator');

router.post('/', validateMac, macController.createMac);

module.exports = router;

Mount it in server.js:

// server.js (snippet)
const macRoutes = require('./backend/routes/macRoutes');
server.use('/api/mac', macRoutes);



⸻

4) Input validation middleware — backend/validators/macValidator.js

Simple validation using a regex and express middleware. If you prefer joi or express-validator that’s also fine; this is minimal and zero-dependency.

// backend/validators/macValidator.js
function isValidMac(mac) {
  // Accepts formats: AA:BB:CC:DD:EE:FF or AABBCCDDEEFF (case-insensitive) or AA-BB-CC-DD-EE-FF
  return /^[0-9A-Fa-f]{12}$/.test(mac.replace(/[:-]/g, ''));
}

exports.validateMac = (req, res, next) => {
  const { mac, name, description, groupId, staticGroupAssignment } = req.body;

  if (!mac || !isValidMac(mac)) {
    return res.status(400).json({ error: 'Invalid or missing mac. Use format AA:BB:CC:DD:EE:FF' });
  }

  // Optional fields minimal checks
  if (groupId && typeof groupId !== 'string') {
    return res.status(400).json({ error: 'groupId must be a string' });
  }

  // convert MAC to canonical form (no separators, uppercase) — ERS accepts many forms but we'll send normalized
  req.body.mac = mac.replace(/[:-]/g, '').toUpperCase();

  // default staticGroupAssignment if not provided
  if (typeof staticGroupAssignment === 'undefined') {
    req.body.staticGroupAssignment = true;
  } else {
    req.body.staticGroupAssignment = !!staticGroupAssignment;
  }

  next();
};



⸻

5) Controller — backend/controllers/macController.js

Controller handles request/response and calls service. Keep it small.

const ersService = require('../services/ersService');

exports.createMac = async (req, res) => {
  try {
    const { groupId, description, staticGroupAssignment, mac, name } = req.body;

    // Map to ERS payload shape
    const ersPayload = {
      ERSEndPoint: {
        groupId: groupId || '',
        description: description || '',
        staticGroupAssignment: !!staticGroupAssignment,
        mac, // normalized by validator
        name: name || `endpoint-${mac}`
      }
    };

    const ersResponse = await ersService.createEndpoint(ersPayload);

    // Optionally, persist to DB here later (ersResponse + request info)

    return res.status(201).json({
      status: 'success',
      message: 'MAC added to ERS',
      ers: ersResponse.data ?? ersResponse
    });
  } catch (err) {
    // ersService throws with informative error
    const status = err.statusCode || 500;
    return res.status(status).json({
      status: 'error',
      message: err.message || 'Failed to add MAC',
      details: err.details || null
    });
  }
};



⸻

6) Service — actual call to ERS — backend/services/ersService.js

Use axios and https.Agent. Prefer auth: {username, password} so Axios handles Base64. Respect ERS_REJECT_UNAUTHORIZED from env (for dev) but in production supply proper CA.

// backend/services/ersService.js
const axios = require('axios');
const https = require('https');

const ERS_BASE_URL = process.env.ERS_BASE_URL;
const ERS_USER = process.env.ERS_USER;
const ERS_PASS = process.env.ERS_PASS;
const TIMEOUT = parseInt(process.env.ERS_TIMEOUT_MS || '10000', 10);
const REJECT_UNAUTHORIZED = process.env.ERS_REJECT_UNAUTHORIZED !== 'false'; // default true

const httpsAgent = new https.Agent({
  rejectUnauthorized: REJECT_UNAUTHORIZED
});

async function createEndpoint(payload) {
  if (!ERS_BASE_URL || !ERS_USER) {
    throw new Error('ERS configuration missing in environment');
  }

  const url = `${ERS_BASE_URL.replace(/\/$/, '')}/ers/config/endpoint`;

  try {
    const resp = await axios.post(url, payload, {
      httpsAgent,
      timeout: TIMEOUT,
      auth: { username: ERS_USER, password: ERS_PASS },
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    });

    // return entire axios response so controller can decide what to do
    return resp;
  } catch (err) {
    // Normalize error thrown up to controller
    let message = err.message;
    let details = null;
    let statusCode = 500;

    if (err.response) {
      // Server returned a response (4xx/5xx)
      statusCode = err.response.status;
      details = err.response.data;
      message = `ERS returned ${statusCode}`;
    } else if (err.request) {
      // No response received
      message = 'No response from ERS';
    }

    const error = new Error(message);
    error.details = details;
    error.statusCode = statusCode;
    throw error;
  }
}

module.exports = {
  createEndpoint
};



⸻

7) Example curl (testing)

Assume you started your server on port 3000 and mounted route at /api/mac.

curl -k -v http://localhost:3000/api/mac \
  -H "Content-Type: application/json" \
  -d '{
    "groupId": "12345",
    "description": "Test endpoint",
    "staticGroupAssignment": true,
    "mac": "aa:bb:cc:dd:ee:ff",
    "name": "my-device-1"
  }'

If all goes well you should get a 201 with ers response body.

⸻

8) Frontend call (Next.js)

From any frontend page or client component:

// using fetch
const resp = await fetch('/api/mac', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    groupId: '123',
    description: 'some desc',
    mac: 'AA:BB:CC:DD:EE:FF',
    name: 'device1'
  })
});

const data = await resp.json();
console.log(data);

Or using axios:

axios.post('/api/mac', { mac, name, description, groupId })
  .then(r => console.log(r.data))
  .catch(err => console.error(err));



⸻

9) Error cases & how they appear to caller
	•	Validation error — status 400, message describing invalid MAC.
	•	Auth failure — ERS responds 401 → controller returns 401 with details from ERS.
	•	ERS error (4xx/5xx) — controller forwards relevant status and details.
	•	Network/TLS — 500 with No response from ERS or certificate details.

Make sure front-end surfaces friendly errors to users.

⸻

10) Where to add DB later (quick notes)

When ready to persist:
	•	Create backend/db/models/Endpoint.js (Sequelize / TypeORM / Prisma) with fields: mac, name, description, ers_id, ers_response, created_by, created_at.
	•	In macController.createMac, after a successful ersService.createEndpoint, insert a DB record with the returned ERS identifier (if any) and the request metadata.
	•	Add service functions in backend/services/dbService.js to keep separation.

⸻

11) Extra improvements you may add later (optional)
	•	Rate-limit / concurrency control (if many requests)
	•	Retry logic with exponential backoff for transient network failures
	•	Logging with correlation ID for tracing external calls
	•	Input sanitization and normalization library (e.g., validator.js)
	•	Unit tests for validator + integration test mocking ERS (nock)
	•	Role-based access control on /api/mac (only certain users can add endpoints)

⸻

12) Quick checklist before running
	•	npm i axios (and any validator libs you choose)
	•	Add env vars in .env.uat or local .env
	•	Mount route and restart node server.js
	•	Test with the curl example
	•	If ERS uses self-signed cert: either set ERS_REJECT_UNAUTHORIZED=false (dev only) or provide proper CA

⸻

If you want, I can:
	•	Generate the exact files and paste full code for each file so you can drop them into your repo
	•	Or convert the validator to Joi or express-validator
	•	Or add a simple DB schema using Sequelize/Prisma and show how to save responses

Which of those next steps would you like me to do now?
